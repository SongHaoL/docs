(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{668:function(t,v,_){"use strict";_.r(v);var e=_(15),o=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器同源策略"}},[t._v("浏览器同源策略")]),t._v(" "),_("ul",[_("li",[t._v("2021.04.29")])]),t._v(" "),_("p",[t._v("当浏览器访问 "),_("code",[t._v("URL")]),t._v(" 地址的协议（schema）/ 端口（port）/ 域名（host），三者中有任何一个与当前的 URL 片段信息不匹配的时候，就产生了跨域问题。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("当前地址")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("请求地址")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("是否跨域")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("http://www.juejin.com:80")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("https://www.juejin.com:80")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是(协议不同)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("http://www.juejin.com:80")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("http://www.juejin.cn:80")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是(域名不同)")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("http://www.juejin.com:80")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("http://www.juejin.com:90")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("是(端口不同)")])])])]),t._v(" "),_("h2",{attrs:{id:"跨域的说明"}},[t._v("跨域的说明")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("跨域，是浏览器提供的一种保护手段，服务端是不存在跨域这一说的。这也就是为什么现在前后端分离的开发模式下，前端比较依赖 "),_("code",[t._v("webpack-dev-server")]),t._v(" 启动代理服务来中转和代理后台接口的原因，因为两个服务器之间相互通信是没有跨域障碍的。")])]),t._v(" "),_("li",[_("p",[t._v("跨域，是对于 "),_("code",[t._v("XMLHttpRequest")]),t._v(" 来说的，"),_("strong",[t._v("浏览器获取不同源服务器下的静态资源，是没有跨域限制的")]),t._v("，这也是 "),_("code",[t._v("JSONP")]),t._v(" 跨域请求得以实现的本质。")])]),t._v(" "),_("li",[_("p",[t._v("不同于 "),_("code",[t._v("XMLHttpRequest")]),t._v(" 的是，通过 "),_("code",[t._v("src")]),t._v(" 属性加载的脚本资源，浏览器限制了 "),_("code",[t._v("Javascript")]),t._v(" 的权限，使其不能读写、返回内容。")])]),t._v(" "),_("li",[_("p",[t._v("对于浏览器来说，除了 "),_("code",[t._v("DOM")]),t._v(" 、"),_("code",[t._v("Cookie")]),t._v("、"),_("code",[t._v("XMLHttpRequest")]),t._v(" 会收到同源策略限制以外，一些常见的插件，比如 "),_("code",[t._v("Flash")]),t._v("、"),_("code",[t._v("Java Applet")]),t._v(" 、"),_("code",[t._v("Silverlight")]),t._v("、"),_("code",[t._v("Google Gears")]),t._v(" 等也都有自己的控制策略。")])])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("当浏览器向不同域的服务器发送请求时，请求是真能发出去，对方服务端也是真能接收到请求，并且真能给你的浏览器响应，浏览器也真能接收到有效数据。")]),t._v(" "),_("p",[t._v("但是，如果在"),_("code",[t._v("跨域")]),t._v("的情况下、服务端返回数据的响应头里的 "),_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 字段，没有把当前域名列进白名单，那么浏览器会把服务端返回的数据给藏起来，不告诉你，然后给你抛个 "),_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 的错误。")])]),t._v(" "),_("h3",{attrs:{id:"为什么资源文件不受同源策略限制呢？"}},[_("strong",[t._v("为什么资源文件不受同源策略限制呢？")])]),t._v(" "),_("p",[t._v("假如说资源文件也被限制跨域，那么现在大量使用的 "),_("code",[t._v("CDN 缓存策略")]),t._v("基本就没办法用了。而且现在很多网站的资源文件，都会放到云服务器的 "),_("code",[t._v("OSS")]),t._v(" 上，"),_("code",[t._v("OSS")]),t._v(" 资源对应的 "),_("code",[t._v("url")]),t._v(" 地址肯定是不同域的，那这些资源也不能使用了。")]),t._v(" "),_("h2",{attrs:{id:"access-control-allow-origin"}},[t._v("Access-Control-Allow-Origin")]),t._v(" "),_("p",[_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 标识了服务器允许的跨域白名单，它有以下几种设置方法：")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("直接设置 "),_("code",[t._v("*")]),t._v(" 通配符，简单粗暴，但是这么做等于把服务器的所有接口资源对外完全暴露，是不安全的。")])]),t._v(" "),_("li",[_("p",[t._v("设置指定域，比如 "),_("code",[t._v("Access-Control-Allow-Origin: https://www.baidu.com")]),t._v(" ，这样只会允许指定域的请求进行跨域访问。")])]),t._v(" "),_("li",[_("p",[t._v("由后端动态设置。"),_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 限制只能写一个白名单，但是当我们有多个域都需要跨域请求怎么呢？这个时候，这时可以由服务端自己维护一套白名单列表，在请求进来的时候对请求的源 "),_("code",[t._v("host")]),t._v(" 进行白名单比对，如果在白名单中，就将这个 "),_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 动态设置上去，然后返回响应。")])])]),t._v(" "),_("h2",{attrs:{id:"cors-的预请求"}},[t._v("CORS 的预请求")]),t._v(" "),_("p",[t._v("如果我们像上面一样，只设置了 "),_("code",[t._v("Access-Control-Allow-Origin")]),t._v(" 白名单，是否就可以完全畅通无阻地进行跨域了呢？并不是。\n就算对端开启了域名白名单认证，然鹅有一些操作仍然是需要进一步认证的，这种进一步的认证操作，就是 "),_("code",[t._v("CORS")]),t._v(" 预请求。")]),t._v(" "),_("h2",{attrs:{id:"预请求触发过程"}},[t._v("预请求触发过程")]),t._v(" "),_("p",[t._v("浏览器预请求的触发条件，是判断本次请求是否属于一个简单请求。")]),t._v(" "),_("p",[t._v("如果本次请求属于一个复杂请求，那么在发送正式的跨域请求之前，浏览器会先准备一个名为 "),_("code",[t._v("OPTIONS")]),t._v(" 的 "),_("code",[t._v("HTTP Method")]),t._v(" ，作为预请求发送。")]),t._v(" "),_("p",[t._v("在服务器通过预请求后，下面浏览器才会发生正式的数据请求。整个请求过程其实是发生了两次请求："),_("code",[t._v("一个预检请求")]),t._v("，以及后续的实际数据请求。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("当我们使用原生的 fetch 去请求时,当发生跨域时，fetch 会先发送一个"),_("code",[t._v("OPTIONS")]),t._v("请求，来确认服务器是否允许接受请求。")]),t._v(" "),_("p",[t._v("服务器同意后，才会发送真正的请求。")])]),t._v(" "),_("h2",{attrs:{id:"简单请求"}},[t._v("简单请求")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("请求方式只能是 "),_("code",[t._v("GET")]),t._v("、"),_("code",[t._v("POST")]),t._v("、"),_("code",[t._v("HEAD")])])]),t._v(" "),_("li",[_("p",[t._v("请求头字段只允许：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("Accept")])]),t._v(" "),_("li",[_("code",[t._v("Accept-Language")])]),t._v(" "),_("li",[_("code",[t._v("Content-Language")])]),t._v(" "),_("li",[_("code",[t._v("Content-Type")])])])]),t._v(" "),_("li",[_("p",[_("code",[t._v("Content-Type")]),t._v(" 的值仅限于：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("text/plain")])]),t._v(" "),_("li",[_("code",[t._v("multipart/form-data")])]),t._v(" "),_("li",[_("code",[t._v("application/x-www-form-urlencoded")])])])]),t._v(" "),_("li",[_("p",[_("code",[t._v("XMLHttpRequestUpload")]),t._v(" 对象均没有注册任何事件监听器（了解就好）。")])]),t._v(" "),_("li",[_("p",[t._v("请求中没有使用 "),_("code",[t._v("ReadableStream")]),t._v(" 对象（了解就好）。")])])]),t._v(" "),_("h2",{attrs:{id:"复杂请求"}},[t._v("复杂请求")]),t._v(" "),_("p",[t._v("除了简单请求里定义的，都是复杂请求，统统需要预请求。")]),t._v(" "),_("h2",{attrs:{id:"预请求的验证"}},[t._v("预请求的验证")]),t._v(" "),_("p",[t._v("那么怎样使预检请求成功认证呢？还是需要服务端继续帮忙设置请求头的白名单：")]),t._v(" "),_("ol",[_("li",[_("code",[t._v("Access-Control-Allow-Headers")]),t._v("，设置允许的额外请求头字段。")]),t._v(" "),_("li",[_("code",[t._v("Access-Control-Allow-Methods")]),t._v("，设置允许的额外请求方法。")]),t._v(" "),_("li",[_("code",[t._v("Access-Control-Max-Age")]),t._v(" （单位/秒），指定了预请求的结果能够被缓存多久，在这个时间范围内，再次发送跨域请求不会被预检。")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("更加完整的跨域信息可以"),_("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击这里查看更多"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=o.exports}}]);