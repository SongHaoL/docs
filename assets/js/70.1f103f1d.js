(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{691:function(t,a,s){"use strict";s.r(a);var n=s(15),v=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"连续赋值问题"}},[t._v("连续赋值问题")]),t._v(" "),s("ul",[s("li",[t._v("2021.04.12")])]),t._v(" "),s("p",[t._v("关于"),s("code",[t._v("javascript")]),t._v("连续赋值问题,我们先来看一段代码:")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\na"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       \nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// {n:2}")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),s("p",[t._v("首先"),s("code",[t._v("let a = {n : 1};")]),t._v("定义了一个引用类型变量"),s("code",[t._v("a")]),t._v(",在栈中存储了一个变量"),s("code",[t._v("a")]),t._v("的内存地址,在堆(内存)中开辟了一个空间存放对应的值"),s("code",[t._v("{n:1}")]),t._v("。")]),t._v(" "),s("p",[t._v("其次"),s("code",[t._v("let b = a;")]),t._v("在栈中写入了b,并将a指向堆中的地址索引赋值给了b。但是并没有开辟新的存储空间。")]),t._v(" "),s("p",[t._v("接下来执行"),s("code",[t._v("a.x = a = {n:2};")]),t._v("这段代码的执行顺序遵循如下原则:")]),t._v(" "),s("ol",[s("li",[t._v("先获取等号左侧的"),s("code",[t._v("a.x")]),t._v("，但"),s("code",[t._v("a.x")]),t._v("并不存在，于是JS为（堆内存中的）对象创建一个新成员"),s("code",[t._v("x")]),t._v("，这个成员的初始值为"),s("code",[t._v("undefined")]),t._v("。")])]),t._v(" "),s("p",[s("strong",[t._v("这也是为什么直接引用一个未定义的变量会报错，但是直接引用一个对象的不存在的成员时，会返回"),s("code",[t._v("undefined")]),t._v("。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("创建完成后，目标指针已经指向了这个新成员x，并会先挂起，等待等号右侧的内容有结果了，再完成赋值。")])]),t._v(" "),s("li",[s("p",[t._v("接着执行"),s("code",[t._v("a = {n:2};")]),t._v("发现这是个简单的赋值语句,于是将堆中a存储的值修改为了"),s("code",[t._v("{n:2}")]),t._v("。")])])]),t._v(" "),s("p",[s("strong",[t._v("这里需要特别注意，这个"),s("code",[t._v("a")]),t._v("已经不是开头的那个"),s("code",[t._v("a")]),t._v("，而是一个全新的"),s("code",[t._v("a")]),t._v("。这个新"),s("code",[t._v("a")]),t._v("指针已经不是指向原来的值的那个堆内存，而是分配了一个新的堆内存。但是原来旧的堆内存因为还有"),s("code",[t._v("b")]),t._v("在占用，所以并未被回收。")])]),t._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("p",[t._v("等待上述语句执行完成后就执行之前等待的命令,将新生成"),s("code",[t._v("a")]),t._v("的索引地址赋值给了"),s("code",[t._v("x")]),t._v(",因此"),s("code",[t._v("x")]),t._v("的值也就变成了"),s("code",[t._v("{n:2}")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("等待上述代码执行完成后,此时"),s("code",[t._v("b = { n:1, x: { n:2 }}")]),t._v(","),s("code",[t._v("a = { n: 2}")]),t._v("。")])])]),t._v(" "),s("p",[t._v("因此也就有了上述的代码结果。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("总结:")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("基础类型的存储是存在栈中的,引用类型的存储是在栈中存储堆的索引,在堆中开辟空间存储变量的值。")])]),t._v(" "),s("li",[s("p",[t._v("当访问一个对象的属性的时候,如果属性不存在会被赋值为"),s("code",[t._v("undefined")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("当进行连续赋值的时候,"),s("code",[t._v(".")]),t._v("属性访问优先级会大于"),s("code",[t._v("=")]),t._v("赋值,且当成员等待赋值的时候,锁定的赋值目标是成员，而非对象。")])]),t._v(" "),s("li",[s("p",[t._v("对象重新赋值时，并非是修改原堆内存的值，而是重新分配堆内存，栈内存中的指针会做相应修改。")])]),t._v(" "),s("li",[s("p",[t._v("如果原堆内存有多个栈内存指向它，由于引用还存在，原堆内存的数据不会消失。如果堆内存再无其它引用，则会被JS的垃圾回收机制回收。对象的成员对象也一样。")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);