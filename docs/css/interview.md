# 面试相关知识点

## 简单介绍使用图片 base64 编码的优点和缺点?

- 2020.05.20

> base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的
url属性。

**使用base64的优点是：**

- 减少一个图片的HTTP请求

**使用base64的缺点是：**

1. 根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体
积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。

2. 使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要
差很多。

3. 兼容性的问题，ie8以前的浏览器不支持。

一般一些网站的小图标可以使用base64图片来引入。

## margin 重叠问题的理解?

- 2020.05.20

> 块级元素的上外边距`（margin-top）`与下外边距`（margin-bottom）`有时会合并为单个外边距，这样的现象称为`“margin合并”`。

产生折叠的必备条件：`margin`必须是邻接的!

**根据w3c规范，两个margin是邻接的必须满足以下条件：**

- 必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。
- 没有线盒，没有空隙，没有`padding`和`border`将他们分隔开
- 都属于垂直方向上相邻的外边距，可以是下面任意一种情况
- 元素的margin-top与其第一个常规文档流的子元素的margin-top
- 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top
- height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom
- 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom

### margin合并的3种场景：

#### 1. 相邻兄弟元素margin合并。

解决方案: 设置块状格式化上下文元素（BFC）

#### 2. 父级和第一个/最后一个子元素的margin合并。

**对于margin-top合并，可以进行如下操作（满足一个条件即可）：**

- 父元素设置为块状格式化上下文元素；
- 父元素设置border-top值；
- 父元素设置padding-top值；
- 父元素和第一个子元素之间添加内联元素进行分隔。

**对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：**

- 父元素设置为块状格式化上下文元素；
- 父元素设置border-bottom值；
- 父元素设置padding-bottom值；
- 父元素和最后一个子元素之间添加内联元素进行分隔；
- 父元素设置height、min-height或max-height。

#### 3. 空块级元素的margin合并。

- 设置垂直方向的border；
- 设置垂直方向的padding；
- 里面添加内联元素（直接Space键空格是没用的）；
- 设置height或者min-height。

## BFC(块级格式化上下文)

- 2020.05.20

> `BFC`是一个独立的渲染区域，只有`Block-level box`参与， 它规定了内部的`Block-level Box`如何布局，并且与这个区域外部毫不相干。`BFC` 就好像一个结界，结界里面的东西不能影响外面的布局，也就是说，BFC的子元素再翻江倒海，都不会影响外面的元素。 所以：

- BFC本身不会发生`margin`重叠。
- BFC可以彻底解决子元素浮动带来的的高度坍塌和文字环绕问题。

### BFC的创建方法
1. 根元素；
2. 浮动元素 (float不为none的元素)；
3. 绝对定位元素 (元素的position为absolute或fixed)；
4. inline-blocks(元素的 display: inline-block)；
5. 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；
6. overflow的值不为visible的元素；
7. 弹性盒 flex boxes (元素的display: flex或inline-flex)；

:::warning
BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。
:::

## CSS 优化、提高性能的方法有哪些？

- 2020.05.20

### 加载性能：

（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。
（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top0bottom0;但margin-bottom:bot
tom;margin-left:left;执行的效率更高。
（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

### 选择器性能：

（1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到
左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；

（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹
配它们了）。

（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。

（4）尽量少的去对标签进行选择，而是用class。

（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过
三层，更多的使用类来关联每一个标签元素。

（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

渲染性能：

（1）慎重使用高性能属性：浮动、定位。

（2）尽量减少页面重排、重绘。

（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。

（4）属性值为0时，不加单位。

（5）属性值为浮动小数0.**，可以省略小数点之前的0。

（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。

（7）不使用@import前缀，它会影响css的加载速度。

（8）选择器优化嵌套，尽量避免层级过深。

（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清
楚，再使用。

（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。

（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏
览器在下载webfonts时会阻塞页面渲染损伤性能。

可维护性、健壮性：

（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。
（2）样式与内容分离：将css代码定义到外部css中。